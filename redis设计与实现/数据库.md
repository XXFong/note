# 数据库

## 1.1 服务器中的数据库
1.  Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数据中，db数组的每项都是一个redis.h/redisDB结构，每个redisDB结构代表一个数据库
2.  初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库
3.  dbnum属性的值由服务器配置的database选项决定，默认情况下该值为16

## 1.2 切换数据库
每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象
默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库
服务器内部，客户端状态redis建Client结构的db属性记录了客户端当前的目标数据库，这个属性是一个纸箱redisDB结构的指针
redisClient.db指针纸箱redisServer.db数组中的其中一个元素，而被指向的元素就是客户端的目标数据库

## 1.3 数据库键空间
Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redisDb结构标识，其中redisDb结构的dict字典保存了数据库中的所有键值对，称这个字典为键空间
键空间和用户所见的数据库是直接对应的：
1.  键空间的键也就是数据库的键，每个键都是一个字符串对象
2.  键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象、有序集合对象中任意一种Redis对象
因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的

### 1.3.1 添加新键
添加一个新键值对到数据库，实际上就是将一个键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象

### 1.3.2 删除键
删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象

### 1.3.3 更新键
对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同

### 1.3.4 对键取值
对一个数据库进取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同

### 1.3.5 其他键空间操作
参考文档。。。

### 1.3.6 读写键空间时的维护操作
当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行执行的读写操作，还会执行一些额外的维护操作，其中包括：
1.  在读取一个键之后(读操作和写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中(hit)次数或者键空间不命中(miss)次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性查看
2.  在读取一个键之后，服务器会更新键的LRU(最后一次使用)时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime<key>命令可以查看键key的闲置时间
3.  如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作
4.  如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty)，从而让事务注意到这个键已经被修改过
5.  服务器每次修改一个键之后，都会对脏(dirty)键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作
6.  如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知

## 1.4 设置键的生存时间或过期时间
通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中某个键设置生存时间(Time To Live, TTL)，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键
tips： SETEX命令可以在设置一个字符串键的同时为键设置过期时间
与EXPIRE命令或者PEXPIRE命令类似，客户端可以通过EXPIREAT命令或者PEXPIREAT命令，以秒或者毫秒给数据库的某个键设置过期时间
TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间

### 1.4.1 设置过期时间
Redis有四个不同的命令可以用于设置键的生存时间或者过期时间
1.  EXPIRE
2.  PEXPIRE
3.  EXPIREAT
4.  PEXPIREAT
实际上EXPIRE、PEXPIRE、EXPIREAT命令都是使用PEXPIREAT命令来实现的

### 1.4.2 保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：
1.  过期字典的键是一个指针，这个指针纸箱键空间中的某件键对象
2.  过去字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间->一个毫秒精度的UNIX时间戳
tips：实际上键空间的键和过期字典的键都纸箱同一个键对象，所以不会出现任何重复对象，也不会浪费空间
当客户端执行PEXPIREAT命令(获取其他三个会转换成PEXPIREAT命令的命令)为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间

### 1.4.3 移除过期时间
PERSIST命令可以移除一个键的过期时间
PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值(过期时间)在过期字典中的关联

### 1.4.4 计算并返回剩余生存时间
TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间
TTL命令和PTTL命令都是通过计算键的过期时间和当前时间之间的差来实现的

### 1.4.5 过去键的判定
通过过期字典，程序可以用一下步骤检查一个给定键是否过期：
1.  检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间
2.  检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则，键未过期
tips：使用TTL和PTTL命令，返回值大于0说明键未过期。实际中Redis检查键是否过期的方法和is_expired函数描述的方法一直，因为直接访问字典比执行一个命令稍快一些

## 1.5 过期键删除策略
如果一个键过期了，那么什么时候会被删除呢？
1.  定时删除：在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作
2.  惰性删除：放任键过期不管，但是每次从键空间过去键时，都检查取得的键是否过期，如果过期，就删除该键；如果没有过期，就返回该键
3.  定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定
在三种策略中，第一和低端三种为主动删除策略，而第二种则为被动删除策略

### 1.5.1 定时删除
定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放键所占用的内存
另一方面，定时删除策略的缺点是，它对CPU时间是最不有好的：在过期键较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是cpu时间非常进行的情况下，
将CPU时间用在删除和当前任务无关的过期键上，无疑是对服务器的响应时间和吞吐量造成影响
因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段并不现实

### 1.5.2 惰性删除
惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除无关的过期键上花费任何CPU时间
缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放
在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远不会被删除(除非手动执行FLUSHDB)，
可以认为是一种内存泄漏->无用的垃圾数据占用了大量的内存，而服务器却不会主动去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不大行的啦

### 1.5.3 定期删除
以上两种删除方式在单一使用的时候都有明显的缺点：
1.  定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量
2.  惰性删除太浪费内存，有内存泄漏的风险
定期删除策略是前两种策略的一种整合和折中：
1.  定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的市场和频率减少删除操作对CPU时间的影响
2.  除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费
定期删除策略的难点是确定删除操作执行的时长和频率：
1.  如果删除操作执行太频繁，或者执行时间太长，定期删除策略会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上
2.  如果删除操作执行太少或者执行时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况
因为采用定期删除策略的话，服务器必须根据情况，合理设置删除操作的执行时长和执行频率

## 1.6 Redis的过期键删除策略
Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存之间取得平衡

### 1.6.1 惰性删除策略的实现
过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：
1.  如果输入键已经过期，那么expireIfNeeded将输入键从数据库中删除
2.  如果输入键未过期，那么expireIfNeeded函数不做动作
expireIfNeeded函数像是一个过滤器，可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键
另外，因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况：
1.  当键存在时，命令按照键存在的情况执行
2.  当键不存在或者键因为过期而被expireIfNeeded函数删除时，命令按照键不存在的情况执行

### 1.6.2 定期删除策略的实现
过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用
它在规定的时间内，分多次遍历服务器中各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键
1.  函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键
2.  全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。
3.  随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数current_db变量重置为0，然后再次开始新一轮的检查工作

## 1.7 AOF、RDB和复制功能对过期键的处理
### 1.7.1 生成RDB文件
在执行SAVE命令时或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中

### 1.7.2 载入RDB文件
在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
1.  如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略
2.  如果服务器以次服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，无论是否过期都会被载入数据库中。不过因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以一般来说过期键对载入RDB文件的从服务器也不会造成影响

### 1.7.3 AOF文件写入
当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但他还没被惰性删除或者定期删除，，那么AOF文件不会因为这个过期键而产生任何影响
当过期键被惰性删除或者定期删除之后，程序回想AOF文件追加(append)一条DEL命令，来显示地记录该键已被删除
例子：客户端使用GET message命令，试图访问过期的message键，那么服务器将执行一下三个动作：
1.  从数据库删除message键
2.  追加一条DEL message命令到AOF文件
3.  向执行GET命令的客户端返回空回复

### 1.7.4 AOF重写
和生成RDB文件类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中

### 1.7.5 复制
当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制：
1.  主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告诉从服务器删除这个过期键
2.  从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续处理未过期的键一样来处理过期键
3.  从服务器只有接收到主服务器发来的DEL命令之后，才会删除过期键
通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会存在

## 1.8 数据库通知
数据库通知这个功能可以让客户端通过订阅给定的频道或者模式，来货值数据库中键的变化，以及数据库中命令的执行情况
键空间通知(key-space notification)关注"某个键执行了什么命令"
键事件通知(key-space notification)关注"某个命令被什么键执行了"
服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：
1.  想让服务器发送所有类型的键空间通知和键事件通知，可以设置选项值为AKE
2.  想让服务器发送所有类型的键空间通知，可以设置选项值为AK
3.  想让服务器发送所有类型的键事件通知，可以设置选项值为AE
4.  想让服务器只发送和字符串键相关的键空间通知，可以设置选项值为K$
5.  想让服务器只发送和列表键相关键事件通知，可以设置选项值为El

### 1.8.1 发送通知
发送数据库通知的功能有notify.c\notifyKeyspaceEvent函数实现的：
void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);
函数的type参数是当前想要发送通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知
event、keys和dbid分别是事件名称、产生事件的键、以及产生事件的数据库号码，函数会根据type参数和这三个参数来构建事件通知的内容，以及接收通知的频道号

### 1.8.2 发送通知的实现
1.  如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不作任何动作
2.  如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送空间通知，如果允许的话，程序就会构建并发送事件通知
3.  最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送时间通知

## 1.8 重点回顾
1.  Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量由redisServer.dbnum属性保存
2.  客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库
3.  数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间
4.  因为数据库由字典构成，所有对数据库的操作都是建立在字典操作之上的
5.  数据库的键总是一个字符串对象，而值可以使任意一种Redis对象类型，(字符串对象，列表对象，哈希表对象，集合对象，有序集合对象)->(字符串键，列表键，哈希表键，集合键，有序集合键)
6.  expires字典的键指向数据库中某个键，而值记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳
7.  Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键
8.  执行SAVE或者BGSAVE命令所产生的的新RDB文件不会包含已经过期的键
9.  执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键
10. 当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键
11. 当主服务器删除一个过期键之后，它会想所有从服务发送一条DEL命令，显式地删除过期键
12. 从服务器几时发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一的、中心化的过期键删除策略可以保证主从服务器数据的一致性
13. 当Redis命令对数据库进行修改后，服务器会根据配置向客户端发送数据库通知


