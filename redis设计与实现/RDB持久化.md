# RDB持久化
服务器中非空数据库以及它们的键值对统称为数据库状态
因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，一旦服务器进程退出，服务器中的数据库状态也会消失不见
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中
RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原成RDB文件时的数据库状态
因为RDB文件是保存在硬盘里的，即使服务器进程退出，甚至运行Redis服务器的计算机宕机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态

## 1.1 RDB文件的创建和载入
有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE
1.  SAVE命令会阻塞Redis服务器进程，知道RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
2.  BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求
和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件
tips：因为AOF文件的更新频率通常比RDB文件高，所以：
1.  如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态
2.  只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态

### 1.1.1 SAVE命令执行时的服务器状态
1.  当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行，客户端发送的所有命令请求都会被拒绝
2.  只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理

### 1.1.2 BGSAVE命令执行时的服务器状态
因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令会和平时有所不同
首先，BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程(服务器进程)和子进程同时执行两个rdbSave调用，防止产生竞争条件
其次，BGSAVE命令执行期间，客户端发送的BGSVAE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件
最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：
1.  如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕后执行
2.  如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝
因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行他们只是性能方面的考虑-并发两个子进程，并且同时执行大量的磁盘写入操作，不是好做法

### 1.1.3 RDB文件载入时的服务器状态
服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完毕

## 1.2 自动间隔性保存
因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令
用户可以铜鼓哦save选项设置多个保存条件，但只要其中任意一个被满足，服务器就会执行BGSAVE命令

### 1.2.1 设置保存条件
服务器会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性
1.  struct saveparam *saveparams // 记录了保存条件的数组
saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了save选项设置的保存条件：
1.  time_t seconds // 秒数
2.  int changes // 修改数

### 1.2.2 dirty计数器和lastsave属性
除了saveparams数组外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：
1.  long long dirty // 修改计数器
2.  time_t lastsave // 上一次执行保存的时间
当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新：命令修改了多少次数据库，dirty计算器的值就增加多少

### 1.2.3 检查保存条件是否满足
Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令

## 1.3 RDB文件结构
RDB文件有五个组成部分:REDIS、db_version、databases、EOF、check_sum
RDB文件的最开头是REDIS部分，这个部分长度为5个字节，保存这“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件
dv_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如“0006”就代表RDB文件的版本为第六版
databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：
1.  如果服务器的数据库状态为空(所有数据库都为空)，那么这个部分也为空，长度为0字节
2.  如果服务器的数据库状态为非空(至少一个一个数据库为非空)，那么这个部分也为非空，长度由键值对数量、类型和内容决定
EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了
check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对前四个部分的内容计算得出的。服务器在载入RDB文件时，会将载入数据库所计算出的校验和和check_sum记录的校验和进行对比，以此检查RDB文件是否有出错或者损坏

### 1.3.1 databases部分
一个RDB文件的databases部分可以保存任意多个非空数据库
每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分
SELECTDB常量的长度为1字节，当读入程序遇到该值时，就知道接下来要读入一个数据库号码
db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节
当程序读入db_number部分之后，服务器就会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入正确的数据库中
key_value_pairs部分保存了数据库中所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。key_value_pairs部分的长度与键值对数量、类型、内容以及是否有过期时间等条件关联

### 1.3.2 key_value_pairs部分
RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内
不带过期时间的键值对在RDB文件中有TYPE、key、value三部分组成
TYPE记录了value的类型，长度为1字节，值可以是以下常量其中一个：
1.  REDIS_RDB_TYPE_STRING
2.  REDIS_RDB_TYPE_LIST
3.  REDIS_RDB_TYPE_SET
4.  REDIS_RDB_TYPE_ZSET
5.  REDIS_RDB_TYPE_HASH
6.  REDIS_RDB_TYPE_LIST_ZIPLIST
7.  REDIS_RDB_TYPE_SET_INTSET
8.  REDIS_RDB_TYPE_ZSET_ZIPLIST
9.  REDIS_RDB_TYPE_HASH_ZIPLIST
以上每个TYPE常量都代表了一种对象类型或者底层编码，当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值决定如何读入和解释value的数据。key和value分别保存了键值对的键对象和值对象：
1.  key总是字符串对象，他的编码方式和REDIS_RDB_TYPE_STRING类型的value一样
2.  根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同
带有过去时间的键值对在RDB文件中有EXPIRETIME_MS、ms、TYPE、key、value五个部分
1.  EXPIRETIME_MS常量的长度为1字节，他告知读入程序接下来要读入的是一个以毫秒为单位的过期时间
2.  ms是一个8字节长的带符号整数，记录了一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间



