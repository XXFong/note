# 简单动态字符串Simple Dynamic String

## 用途
###  实现字符串对象（StringObject）
1. redis是KV-DB, Value可是字符串、集合、列表等多种类型的对象，而key总是字符串对象，对于那些包含字符串值的字符串对象来说， 每个字符串对象都包含一个 sds 值 
2.  在 Redis 中， 一个字符串对象除了可以保存字符串值之外， 还可以保存 long 类型的值.


### 在 Redis 程序内部用作 char* 类型的替代品
1.  char*类型功能单一，抽象层次低，不能高效支持(内容追加和长度计算)
2.  在Redis中，客户端传入服务器的协议内容、aof缓存、返回给客户端的回复，等等，这些重要的内容都是由sds类型来保存的


 
## Redis中的字符串
在 C 语言中，字符串可以用一个 \0 结尾的 char 数组来表示
### 不能高效支持(内容追加和长度计算)这两种操作:
1.  每次计算字符串长度(strlen(s))的复杂度为O(N)
2.  对字符串进行N次内容追加，必定需要N次内存重分配

### 字符串表示需是二进制安全的:
1.   程序不应对字符串里面保存的数据做任何假设，数据可以是以\0结尾的C字符串，也可以是单纯的字节数组，或者其他格式的数据


### sds的实现(sdshdr)
1.  int len // 记录buf数组中使用字节的数量，等于SDS所保存的字符串的长度
2.  int free // 记录buf数据中未使用字节的数量
3.  char buf[] // 字节数组， 用于保存字符串

## 优化追加操作
1.  利用sdshdr结构，可用O(1)复杂度获取字符串长度
2.  杜绝缓冲区溢出(C:分配的内存空间不足)
3.  空间预分配: SDS_MAX_PREALLOC的值为1024 * 1024，当大小小于1MB的字符串执行追加操作时，sdsMakeRoomFor就为它们分配多于所需大小一倍的空间；当字符串的大小大于1MB，那么sdsMakeRoomFor就为它们额外多分配1MB的空间(有效减少内存重分配次数)
4.  针对第二点，需根据业务场景分析append频率，append操作较多且字符串占用内存较大的时候，需要修改配置，让服务器定时释放预分配空间。
5.  惰性空间释放: 字符串缩短后，并不马上进内存重分配，而是使用free字段记录数量，等待将来使用

## 二进制安全
1.  C字符串必须符合某种编码，不能有空字串
2.  字符数组buf存放的不是字符，而是二进制数据

## 总结

| C字符串 | SDS |
| ---- | ---- |
| 获取字符串长度复杂度O(N) | 获取字符串长度复杂度O(1) |
| API是不安全的，可能会造成缓冲区溢出 | API是安全的，不会造成缓冲区溢出 |
| 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多需要执行N次内存重分配 |
| 只能保存文本数据 | 可以保存文本或二进制数据 |
| 可以使用所有<string.h>库中的函数 | 可以使用部分<string.h>库中的函数 |


