# 对象
1.  主要数据结构：简单动态字符串、双端链表、字典、压缩列表、整数集合等
2.  Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统
3.  这个系统包含字符串对象、列表对象、哈希对象、集合对象、和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面所介绍的数据结构
4.  通过这五中对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令
5.  另一个好处，可以针对不同的场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率
6.  除此之外，Redis的对象系统还实现了基于引用计数的内存回收机制，当程序不再使用某个对象的时候，这个对象占用的内存会被自动释放；
7.  另外Redis还是通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存
8.  最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会被优先删除

## 1.1 对象的类型与编码
Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值

### 1.1.1 类型
对象的type属性记录了对象的类型，这个属性可以使以下五个之一

| 类型常量 | 对象名称 | 
| ---- | ---- | 
| REDIS_STRING | 字符串对象 | 
| REDIS_LIST | 列表对象 | 
| REDIS_HASH | 哈希对象 | 
| REDIS_SET | 集合对象 | 
| REDIS_ZSET | 有序集合对象 | 

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以使字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种
TYPE命令：对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型

| 对象 | 对象tyoe属性的值 | TYPE命令的输出 | 
| ---- | ---- | ---- |
| 字符串对象 | REDIS_STRING | "string" | 
| 列表对象 | REDIS_LIST | "list" | 
| 哈希对象 | REDIS_HASH | "hash" | 
| 集合对象 | REDIS_SET | "set" | 
| 有序集合对象 | REDIS_ZSET | "zset" |

### 1.1.2 编码和底层实现
对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定

| 编码常量 | 编码所对应的底层数据结构 | 
| ---- | ---- | 
| REDIS_ENCODING_INT | long类型的整数 | 
| REDIS_ENCODING_EMBSTR | embstr编码的简单动态字符串 | 
| REDIS_ENCODING_RAW | 简单动态字符串 | 
| REDIS_ENCODING_HT | 字典 | 
| REDIS_ENCODING_LINKEDLIST | 双端链表 | 
| REDIS_ENCODING_ZIPLIST | 压缩列表 | 
| REDIS_ENCODING_INTSET | 整数集合 | 
| REDIS_ENCODING_SKIPLIST | 跳跃表和字典 | 

每种类型的对象都至少使用了两种不同的编码

| 编码常量 | 编码常量 | 编码所对应的底层数据结构 | 
| ---- | ---- | ---- | 
| REDIS_STRING | REDIS_ENCODING_INT | 使用整数值实现的字符串对象 | 
| REDIS_STRING | REDIS_ENCODING_EMBSTR | 使用embstr编码的简单动态字符串实现的字符串对象 | 
| REDIS_STRING | REDIS_ENCODING_RAW | 使用简单动态字符串的字符串对象 | 
| REDIS_LIST | REDIS_ENCODING_ZIPLIST | 使用了压缩列表实现的列表对象 | 
| REDIS_LIST | REDIS_ENCODING_LINKEDLIST | 使用了双端链表实现的列表对象 | 
| REDIS_HASH | REDIS_ENCODING_ZIPLIST | 使用了压缩列表实现的哈希对象 | 
| REDIS_HASH | REDIS_ENCODING_HT | 使用了字典实现的哈希对象 | 
| REDIS_SET | REDIS_ENCODING_INTSET | 使用了整数集合实现的集合对象 | 
| REDIS_SET | REDIS_ENCODING_HT | 使用了字典实现的集合对象 | 
| REDIS_ZSET | REDIS_ENCODING_ZIPLIST | 使用了压缩列表实现的有序集合对象 | 
| REDIS_ZSET | REDIS_ENCODING_SKIPLIST | 使用了跳跃表和字典实现的有序集合对象 | 

不同编码的对象所对应的OBJECT ENCODING命令输出

| 对象所使用的底层数据结构 | 编码常量 | OBJECT ENCODINF命令输出 | 
| ---- | ---- | ---- |
| 整数 | REDIS_ENCODING_INT | "int" | 
| emstr编码的简单动态字符串(SDS) | REDIS_ENCODING_EMBSTR | "embstr" | 
| 简单动态字符串 | REDIS_ENCODING_RAW | "raw" | 
| 字典 | REDIS_ENCODING_HT | "hashtable" | 
| 双端链表 | REDIS_ENCODING_LINKEDLIST | "linkedlist" |
| 压缩列表 | REDIS_ENCODING_ZIPLIST | "ziplist" | 
| 整数集合 | REDIS_ENCODING_INTSET | "intset" | 
| 跳跃表和字典 | REDIS_ENCODING_SKIPLIST | "skiplist" |

通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率
例子：在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现
1.  因为压缩列表比双端列表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中
2.  随着列表对象包含的元素越来越多，使用压缩列表来保存元素的有事逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面
其他类型的对象也会通过使用不同的编码来进行类似的优化

## 1.2 字符串对象
字符串对象的编码可以使int、raw、或者embstr
如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的prt属性里面(将void*转换成long)，并且将字符串对象的编码设置为int
如果字符串对象保存的是字符串值，并且这个字符串的长度大于32字节，那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串，并将对象编码设置为raw
如果字符串对象保存的是字符串值，并且这个字符串的长度小于等于32字节，那么字符串对象将使用emstr编码的方式来保存这个字符串值
embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都是使用redisObject结构和sdshdr结构来表示字符串对象：
1.  但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，
2.  而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构

embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：
1.  embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次
2.  释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数
3.  因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所有这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的有事
long double类型表示的浮点数在Redis中也是作为字符串值来保存的
有需要的时候程序会将保存在字符串对象中的字符串值转换回浮点数值，进行某些操作(相加等)，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面
字符串对象保存各类型值的编码方式如下:

| 值 | 编码 |
| ---- | ---- | 
| 可以用long类型保存的值 | int | 
| 可以用long double类型保存的浮点数 | embstr和raw | 
| 字符串值，或者因为长度太大而没有办法用long类型表示的整数，又或者因为长度太大而没有办法用long double类型表示的浮点数 | embstr或者raw | 

### 1.2.1 编码转换
int编码的字符串对象和embstr编码饿字符串对象在条件满足的情况下，会被转换成raw编码的字符串对象
1.  对于int编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw
2.  因为Redis没有为embstr编码的字符串对象边写任何修改程序(只有int编码和raw编码的字符串对象有这些程序)， 所以embstr编码的字符串对象实际上是只读的。
    当我们对该字符串对象执行任何修改命令时，程序会将对象的编码从embstr转换为raw，然后再执行修改命令
    因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象
 
### 1.2.2 字符串命令的实现
因为字符串键的值为字符串成对象，所有用于字符串键的所有命令都是针对字符串对象来构建的

## 1.3 列表对象
列表对象的编码可以使ziplist或者linkedlist
ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点(entry)保存了一个列表元素
linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点(node)都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素
tips:linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现，

### 1.3.1 编码转换
当列表对象可以同时满足一下两个条件时，列表对象使用ziplist编码：
1.  列表对象保存的所有字符串元素的长度都小于64字节
2.  列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码
tips:以上条件的上限值是可以修改，具体请看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明

### 1.3.2 列表命令的实现
因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来创建的

## 1.4 哈希对象
哈希对象的编码可以使ziplist或者hashtable
ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再保存了值的压缩列表节点推入压缩列表表尾，因此：
1.  保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后
2.  先添加到哈希对象的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向
hashtable编码的哈希对象使用了字典作为底层实现，哈希对象中的每个键值对都使用一个字典值来保存：
1.  字典的每个键都是一个字符串对象，对象中保存了键值对的键
2.  字段的每个值都是一个字符串对象，对象中保存了键值对的值

### 1.4.1 编码转换
当哈希对象可以同时满足一下两个条件时，哈希对象使用ziplist编码：
1.  哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
2.  哈希对象保存的键值对数量小于512个；不能满足于这两个条件的哈希对象需要使用hashtable编码
tips:条件上限值可以修改，具体请看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明

### 1.4.2 哈希命令的实现
因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的

## 1.5 集合对象
集合对象的编码是intset和hashtable
1.  intset编码的集合对象使用整数集合作为底层实现，集合对象包含的素有元素都保存在整数集合里
2.  hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值全部被设置为NULL

### 1.5.1 编码转换
当集合对象可以同时满足一下两个条件时，对象使用intset编码：
1.  集合对象保存的所有元素都是整数值
2.  集合对象保存的元素数量不超过512个
不能满足这两个条件的集合对象需要使用hashtable编码
tips:第二个条件的上限值可修改，参考set-max-intset-entries选项说明

### 1.5.2 集合命令的实现
因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的

##  1.6 有序集合对象
有序集合的编码可以使ziplist和skiplist
1.  ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员(member)，而第二个元素则保存元素的分值(score)
    压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向
2.  skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字段和一个跳跃表
zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值
通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK，ZRANGE等命令就是基于跳跃表API来实现的
zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中每个键值对都保存了一个集合元素：
字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O(1)复杂度查找给定成员的分值
有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数，tips：虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此浪费内存

### 1.6.1 编码转换
当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：
1.  有序集合保存的元素数量小于128个
2.  有序集合保存的所有元素成员的长度都小于64字节
不能满足以上两天条件的有序集合对象将使用skiplist编码

### 1.6.2 有序集合命令的实现
因为有序集合键的值为哈希对象，所以用于有序集合键的所有命令都是针对哈希对象来构建的

## 1.7 类型检查与命令多态
Redis中用于操作键的命令基本上可以分为两种类型
其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等
而另一种命令只能对特定类型的键执行，比如说：
1.  SET、GET、APPEND、STRLEN等命令只能对字符串键执行
2.  HDEL、HSET、HGET、HLEN等命令只能对哈希键执行
3.  RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行
4.  SADD、SPOP、SINTER、SCARD等命令只能对集合键执行
5.  ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行

### 1.7.1 类型检查的实现
从上面发生类型错误的代码示例可以看出，为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查键的类型是否正确，然后再觉得是否执行给定的命令
类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：
1.  在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令
2.  否则，服务器将拒绝执行命令，并向客户端返回一个类型错误

### 1.7.2 多态命令的实现
Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令
例子：列表对象有ziplist和linkedlist两种编码可用，如果我们对一个键执行LLEN命令，那么服务器出了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的LLEN命令实现：
1.  如果列表对象的编码为ziplist，那么说明列表对象的实现为压缩列表，程序将使用ziplistLen函数来返回列表长度
2.  如果列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用listLength函数来返回双端链表的长度
DEL、EXPIRE等命令和LLEN等命令的区别在于，前者是基于类型的多态---一个命令可以同时用于处理多种不同类型的键，后者是基于编码的多态---一个命令可以同时用于处理多种不同的编码

## 1.8 内存回收
因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数计数实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收
每个对象的引用计数信息有redisObject结构的refcount属性记录：
1.  int refcount // 引用计数
对象的引用计数信息会随着对象的使用状态不断变化
1.  在创建一个新对象时，引用计数的值会被初始化为1
2.  当对象被一个新程序使用时，它的引用计数值会被增1
3.  当对象不再被一个程序使用时，它的引用计数会被减1
4.  当对象的引用计数值变为0时，对象所占用的内存会被释放
对象的整个生命周期可以划分为创建对象、操作对象、释放对象、三个阶段

## 1.9 对象共享
除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用
在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：
1.  将数据库键的值指针指向一个现有的值对象
2.  将被共享的值对象的引用计数加1
目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到这些字符串对象时，服务器就会使用这些共享对象，而不是新创建对象
tips；创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改

### 1.9.1 为什么Redis不共享包含字符串的对象
当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，
只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，
而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：
如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O（1）；
如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）；
如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N2）。
因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。

## 1.10 对象的空转时长
除了type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间(unsigned lru:22)
OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时间就是通过将当前时间减去键的值对象的lur时间计算得出的(该命令范围键的值对象时，不会修改值对象的lru属性)
除了可以被OBJECT IDLETIME命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存

## 1.11 重点回顾
1.  Redis数据库中的每个键值对的键和值都是一个对象
2.  Redis共有字符串、列表、哈希、集合、有序集合五中类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率
3.  服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型
4.  Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放
5.  Redis会共享值为0-9999的字符串对象
6.  对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间
