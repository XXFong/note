# 对象
1.  主要数据结构：简单动态字符串、双端链表、字典、压缩列表、整数集合等
2.  Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统
3.  这个系统包含字符串对象、列表对象、哈希对象、集合对象、和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面所介绍的数据结构
4.  通过这五中对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令
5.  另一个好处，可以针对不同的场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率
6.  除此之外，Redis的对象系统还实现了基于引用计数的内存回收机制，当程序不再使用某个对象的时候，这个对象占用的内存会被自动释放；
7.  另外Redis还是通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存
8.  最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会被优先删除

## 1.1 对象的类型与编码
Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值

### 1.1.1 类型
对象的type属性记录了对象的类型，这个属性可以使以下五个之一

| 类型常量 | 对象名称 | 
| ---- | ---- | 
| REDIS_STRING | 字符串对象 | 
| REDIS_LIST | 列表对象 | 
| REDIS_HASH | 哈希对象 | 
| REDIS_SET | 集合对象 | 
| REDIS_ZSET | 有序集合对象 | 

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以使字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种
TYPE命令：对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型

| 对象 | 对象tyoe属性的值 | TYPE命令的输出 | 
| ---- | ---- | ---- |
| 字符串对象 | REDIS_STRING | "string" | 
| 列表对象 | REDIS_LIST | "list" | 
| 哈希对象 | REDIS_HASH | "hash" | 
| 集合对象 | REDIS_SET | "set" | 
| 有序集合对象 | REDIS_ZSET | "zset" |

### 1.1.2 编码和底层实现
对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定

| 编码常量 | 编码所对应的底层数据结构 | 
| ---- | ---- | 
| REDIS_ENCODING_INT | long类型的整数 | 
| REDIS_ENCODING_EMBSTR | embstr编码的简单动态字符串 | 
| REDIS_ENCODING_RAW | 简单动态字符串 | 
| REDIS_ENCODING_HT | 字典 | 
| REDIS_ENCODING_LINKEDLIST | 双端链表 | 
| REDIS_ENCODING_ZIPLIST | 压缩列表 | 
| REDIS_ENCODING_INTSET | 整数集合 | 
| REDIS_ENCODING_SKIPLIST | 跳跃表和字典 | 

每种类型的对象都至少使用了两种不同的编码

| 编码常量 | 编码常量 | 编码所对应的底层数据结构 | 
| ---- | ---- | ---- | 
| REDIS_STRING | REDIS_ENCODING_INT | 使用整数值实现的字符串对象 | 
| REDIS_STRING | REDIS_ENCODING_EMBSTR | 使用embstr编码的简单动态字符串实现的字符串对象 | 
| REDIS_STRING | REDIS_ENCODING_RAW | 使用简单动态字符串的字符串对象 | 
| REDIS_LIST | REDIS_ENCODING_ZIPLIST | 使用了压缩列表实现的列表对象 | 
| REDIS_LIST | REDIS_ENCODING_LINKEDLIST | 使用了双端链表实现的列表对象 | 
| REDIS_HASH | REDIS_ENCODING_ZIPLIST | 使用了压缩列表实现的哈希对象 | 
| REDIS_HASH | REDIS_ENCODING_HT | 使用了字典实现的哈希对象 | 
| REDIS_SET | REDIS_ENCODING_INTSET | 使用了整数集合实现的集合对象 | 
| REDIS_SET | REDIS_ENCODING_HT | 使用了字典实现的集合对象 | 
| REDIS_ZSET | REDIS_ENCODING_ZIPLIST | 使用了压缩列表实现的有序集合对象 | 
| REDIS_ZSET | REDIS_ENCODING_SKIPLIST | 使用了跳跃表和字典实现的有序集合对象 | 

不同编码的对象所对应的OBJECT ENCODING命令输出

| 对象所使用的底层数据结构 | 编码常量 | OBJECT ENCODINF命令输出 | 
| ---- | ---- | ---- |
| 整数 | REDIS_ENCODING_INT | "int" | 
| emstr编码的简单动态字符串(SDS) | REDIS_ENCODING_EMBSTR | "embstr" | 
| 简单动态字符串 | REDIS_ENCODING_RAW | "raw" | 
| 字典 | REDIS_ENCODING_HT | "hashtable" | 
| 双端链表 | REDIS_ENCODING_LINKEDLIST | "linkedlist" |
| 压缩列表 | REDIS_ENCODING_ZIPLIST | "ziplist" | 
| 整数集合 | REDIS_ENCODING_INTSET | "intset" | 
| 跳跃表和字典 | REDIS_ENCODING_SKIPLIST | "skiplist" |

通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率
例子：在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现
1.  因为压缩列表比双端列表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中
2.  随着列表对象包含的元素越来越多，使用压缩列表来保存元素的有事逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面
其他类型的对象也会通过使用不同的编码来进行类似的优化
