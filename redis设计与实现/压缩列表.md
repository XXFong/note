# 压缩列表 ziplist
压缩列表是是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项都是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现
另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现

## 压缩列表的构成
压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。一个压缩列表可以包含任意多个节点(entry)，每个节点可以保存一个字节数组或者一个整数值
1.  uint32_t zlbytes // 记录整个压缩列表占用的内存字节数:在对压缩列表进行内存重分配，或者计算zlend的位置时使用
2.  uint32_t zltail // 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址
3.  uint16_t zllen // 记录了压缩列表包含的节点数量：当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量，当这个值等于UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出
4.  列表节点 entryX // 压缩列表包含的各个节点，节点的长度由节点保存的内容决定
5.  uint8_t zlend // 特殊值0xFF(十进制255)，用于标记压缩列表的末端

## 压缩列表节点的构成
每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种:
1.  长度小于等于63(2^6 - 1)字节的字节数组
2.  长度小于等于16383(2^14 - 1)字节的字节数组
3.  长度小于等于4294967295(2^32 - 1)字节的字节数组
而整数值则可以是以下六种长度的其中一种：
1.  4位长，介于0至12之间的无符号整数
2.  1字节长的有符号整数
3.  3字节长的有符号整数
4.  int16_t类型整数
5.  int32_t类型整数
6.  int64_t类型整数
每个压缩列表都由previous_entry_length、encoding、content三个部分组成

### previous_entry_length
节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以1字节或者5字节：
1.  如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节(即为前一节点的长度)
2.  如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE(十进制254),而之后的四个字节则用于保存前一节点的长度。
因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址

### encoding
节点的encoding属性记录了节点的content属性所保存数据的类型一集长度：
1.  1字节、2字节或者5字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录
2.  1字节长，值得最高位以11开头的是整数编码：这种编码表示节点content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录

### content
节点的content属性负责保存节点的值，节点值可以使一个字节数组或者整数，值得类型和长度由节点的encoding属性决定

| id | previous_entry_length | encoding | content |
| ---- | ---- | ---- | ---- |
| 1 | ... | 00001011 | "hello world" |
| 2 | ... | 11000000 | 10086 |
1.1.  encoding最高两位为00表示节点保存的是一个字节数组
1.2.  encoding后六位001011记录了字节数组的长度11
1.3.  content属性保存着节点的值"hello world"
2.1.  encoding11000000表示节点保存的是一个int16_t类型的整数值
2.2.  content属性保存着节点的值10086

## 连锁更新
由于每个节点的previous_entry_length属性都记录了前一个节点的长度
例子:
1.  在一个压缩列表中有多个连续的、长度介于250字节至253字节之间的节点
2.  因为所以节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性
3.  如果将一个长度大于等于新节点new设置为压缩列表的表头节点，那么new将成为原表头节点e1的前置节点
4.  因为e1的previous_entry_length属性仅长1字节，他不足以保存新节点new的长度，所以程序将对压缩列表进行空间重分配操作，并将e1节点的previous_entry_length属性从1字节扩展为5字节
5.  因为e1原本长度为250字节至253字节之间，在previous_entry_length属性新增了四个字节的空间之后，e1的长度变成了介于254至257字节之间，这个长度是没办法使用1字节长的previous_entry_length属性来保存的
6.  再次进行空间重分配操作，将e2的previous_entry_length也设置为5字节长
7.  以此类推，需要对压缩列表进行多次空间重分配，让每个节点的previous_entry_length属性都符合压缩列表的要求，直至eN

Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为"连续更新(cascade update)"
除了新增节点可能会导致连锁更新之外，删除节点也可能引发连锁更新
因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为(N),所以连锁更新的最坏复杂度为O(N^2)
尽管连续更新的复杂度较高，但真正造成性能问题的几率是很低的：
1.  需要压缩列表中恰好有多个连续的、长度介于250至253字节之间的节点，连锁更新才可能会被引发
2.  即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影像
因此，ziplistPush等命令平均复杂度仅为O(N)

## 重点回顾
1.  压缩列表是一种为节约内存而开发的顺序性数据结构
2.  压缩列表被用作列表键和哈希键的底层实现之一
3.  压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值
4.  添加新节点或者删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高


